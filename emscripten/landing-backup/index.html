<!doctype html>
<html lang="en-us">
  <head>
    <!--
    @licstart
    SONIC ROBO BLAST 2
    -----------------------------------------------------------------------------
    Copyright (C) 1993-1996 by id Software, Inc.
    Copyright (C) 1998-2000 by DooM Legacy Team.
    Copyright (C) 1999-2020 by Sonic Team Junior.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
    @licend
    -->
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta property="og:title" content="Sonic Robo Blast 2 for Web">
    <meta property="og:description" content="Play this 3D Sonic the Hedgehog fangame in your web browser! Works on PC, Chromebook, iPhone, and Android.">
    <meta property="og:image" content="https://srb2web.surge.sh/assets/landing.png">
    <meta property="og:url" content="https://srb2web.surge.sh">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
    <link rel="apple-touch-icon" href="assets/srb2.png">
    <meta name="apple-mobile-web-app-title" content="SRB2">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="assets/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <script src="https://cdn.jsdelivr.net/gh/mazmazz/idb-keyval@idb-version/dist/idb-keyval-iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.2/dist/FileSaver.min.js"></script>
    <!-- {{{ GTAG }}} -->

    <title>Sonic Robo Blast 2</title>
    <style>
      html, body {
        height: 100%;
      }

      body {
        font-family: 'Segoe UI', sans-serif;
        margin: 0;
        padding: none;
        background-color: #000;
        background-image: 
          linear-gradient(90deg, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.80) 10%, rgba(0,0,0,0.80) 90%, rgba(0,0,0,0.25) 100%),
          url(assets/background.jpg);
        background-size: cover;
        background-attachment: fixed;
        background-position: center;
        color: #ffffff;
      }

      body.startedMainLoop {
        background-image: none;
      }

      body.startedMainLoop #content {
        display: none;
      }

      a {
        color: rgb(107, 161, 255);
      }

      a:visited {
        color: #7f6bd1;
      }

      @media (min-width: 320px) {
        #logo {
          width: 120%;
          height: auto;
          margin: 0 -10%;
        }

        #systemArguments, #userArguments {
          width: 120%;
          margin: 0 -10%;
        }
      }

      @media (min-width: 481px) {
        #logo {
          width: 90%;
          height: auto;
        }

        #systemArguments, #userArguments {
          width: 90%;
        }
      }

      @media (min-width: 641px) {
        #logo {
          width: 60%;
          height: auto;
        }

        #systemArguments, #userArguments {
          width: 60%;
        }
      }

      @media (min-width: 1281px) {
        #logo {
          width: 40%;
          height: auto;
        }

        #systemArguments, #userArguments {
          width: 40%;
        }
      }

      #status-cont {
        display: inline-block;
        font-weight: bold;
        text-align: center;
        margin: auto 10%;
      }

      #progress {
        height: 20px;
        width: 256px;
      }

      #canvas, #keyCapture {
          position: fixed;
          top: 0;
          left: 0;
          width: 100% !important;
          height: 100% !important;
          opacity: 0;
      }

      #keyCapture {
        opacity: 0;
        background-color: rgba(0,0,0,0);
        border: 0;
        color: rgba(0,0,0,0);
        z-index: -99999;
      }

      #textForm {
        display: flex;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 2.5em;
        z-index: -99999;
        opacity: 0;
      }

      #textCapture {
        flex-grow: 1;
      }

      #textSubmit {
        width: 6.66em;
      }

      #content {
        width: 100%;
        height: 100%;
        overflow-y: auto;
        text-align: center;
        display: grid;
      }

      button, .button {
        width: 160px;
        height: 48px;
        margin: 0.1em;
        background-color: darkgray;
        background-image: linear-gradient(black, darkgray);
        border: 0.1em gray solid;
        border-radius: 2px;
        color: white;
        font-weight: bold;
        text-align: center;
        line-height: 2.5em;
        display: inline-block;
        cursor: default;
      }

      .blueButton {
        background-color: mediumblue;
        background-image: linear-gradient(black, mediumblue);
        border-color: mediumblue;
      }

      .yellowButton {
        background-color: goldenrod;
        background-image: linear-gradient(black, goldenrod);
        border-color: goldenrod;
      }

      .redButton {
        background-image: linear-gradient(black, crimson);
        border-color: crimson;
      }

      #startbtn {
        background-color: yellow;
        color: black;
        background-image: linear-gradient(yellow, orange);
        border: 0.1em orange solid;
        font-weight: bolder;
        font-size: 1.25em;
        line-height: normal;
        cursor: pointer;
      }

      #notes {
        display: inline-block;
        text-align: start;
      }

      summary {
        margin: 0.75em 0;
        font-size: 1.2em;
      }

      #addonFilesTemplate {
        display: none;
      }

      .addonFilesField {
        display: inline-block;
        width: 100%;
        margin: 0.1em 0;
      }

      #resetbtn {
        display: none;
      }

      .addonFilesField .addonButton {
        width: 2.5em;
      }

      .addonFilesField label,
      .addonFilesField input[type=file] {
        width: 12.5em;
        height: 2.5em;
        margin: 0;
        cursor: pointer;
      }

      .addonFilesField input[type=file] {
        font-size: 1em;
        display: none;
      }

      .addonFilesField .addonDelete {
        width: 2.5em;
        height: 2.5em;
        margin: 0 0 0 0.1em;
      }

      #addonButtonAdd {
        width: 15.4em;
        height: 2.5em;
        margin: 0.1em 0;
      }

      #androidNotice {
        display: none;
      }

      .iOSAgent .noniOS {
        display: none;
      }

      body:not(.iOSAgent) .isiOS {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="content">
      <div id="status-cont" class="emscripten">
        <div id="header">
          <p>
            <img id="logo" src="assets/srb2logo.png"/>
          </p>
        </div>
        <div id="details">
          <p>To play SRB2 for Web, go to <a href="https://mazmazz.github.io/srb2web">https://mazmazz.github.io/srb2web</a>.</p>
          <p><strong style="color:red;">This web page will go dead soon! Update your bookmarks to the link above so you can access the latest version!</strong></p>
          <p class="noniOS">First, save a backup of your game data here. Then, you can upload it onto the new website.</p>
          <p class="isiOS">You should wipe your Program Data here because it is unusable in the new web site. You will download a new copy of the Program Data at the new site.</p>
        </div>
        <div>
          <button class="noniOS" class="redButton" onclick="if (confirm('Are you sure? Once you download your user data, you cannot retrieve it from this page again.')) { DownloadFS().then(_=>ResetProgramData(true, _=>alert('Program data reset.'))).then(_=>DeleteFS('/home/web_user/.srb2', true, _=>alert('User data wiped. You can upload your backup onto the new web site.'))).catch(err=>alert(`Error -- if you did not yet download your user data, then it may be safe.\n\n${err}`)); } return false;">Back up and Wipe</button>
          <button class="isiOS" class="redButton" onclick="if (confirm('Are you sure? You will be unable to retrieve your user data from this page again.')) { ResetProgramData(true, _=>alert('Program data reset.')).then(_=>DeleteFS('/home/web_user/.srb2', true, _=>alert('User data wiped.'))).catch(err=>alert(`Error -- try wiping your program data in the iOS Safari settings.\n\n${err}`)); } return false;">Wipe Program Data</button>
          <button class="yellowButton" onclick="alert('This web page will go dead soon!\n\nUpdate your bookmarks to https:\/\/mazmazz.github.io/srb2web so you can access the latest version.'); window.location.href='https:\/\/mazmazz.github.io/srb2web'; return false;">Go to App</button>
        </div>
        <details id="footer">
          <summary>About</summary>
          <p>Sonic Robo Blast 2 is a 3D Sonic the Hedgehog fangame inspired by the original Sonic games of the 1990s.</p>
          <p>This project allows you to play SRB2 on your web browser, including iPhone and iPad.</p>
          <p>
            Follow the <a href="https://discord.gg/fMuddqH" target="_blank">SRB2 for Web Updates Discord</a> for news and support!
          </p>
          <p><a href="https://github.com/mazmazz/SRB2-emscripten/issues">View issues</a> / <a href="https://github.com/mazmazz/SRB2-emscripten">View source</a></p>
          <p>Contributors:</p>
          <p><a href="https://github.com/mazmazz">mazmazz</a> / <a href="https://github.com/heyjoeway">heyjoeway</a> / <a href="https://github.com/Jimita">Jimita</a></p>
          <p>Follow SRB2:</p>
          <p><a href="https://www.srb2.org">Website</a> / <a href="https://twitter.com/SonicTeamJr">Twitter</a> / <a href="https://discord.com/invite/pYDXzpX">Discord</a></p>
          <span id="newVersion"></span>
          <p style="font-size:xx-small;">
            This software is licensed under GNU General Public License Version 2. See license text at <a href="https://opensource.org/licenses/GPL-2.0" target="_blank">https://opensource.org/licenses/GPL-2.0</a>.
          </p>
          <p style="font-size:xx-small;">
            The <a href="https://musical-artifacts.com/artifacts/400" target="_blank">Florestan Basic GM GS</a> soundfont is created by <a href="http://dev.nando.audio" target="_blank">Nando Florestan</a>.
          </p>
          <p style="font-size:xx-small;">
            Original design and content is copyright 1998-2020 Sonic Team Junior. All non-original material is copyrighted by their respective owners, and no copyright infringement is intended.
          </p>
        </details>
        <div id="copyright">
          <p style="font-size:xx-small;">
            Sonic Robo Blast 2 and Sonic Team Junior are in no way affiliated with SEGA&reg; or Sonic Team.
          </p>
          <p style="font-size:xx-small;">
            Sonic the Hedgehog is a trademark of SEGA&reg;<br/>
            The copyrights of "Sonic the Hedgehog" and all associated characters, names, terms, art, and music thereof belong to SEGA&reg;
          </p>
          <p style="font-size:xx-small;">
            This service is not an official project of Sonic Team Junior.
          </p>
        </div>
      </div>
    </div>
    
    <script type='text/javascript'>
      ////////////////////////////////
      // Utilities
      ////////////////////////////////
      
      var UserAgentIsiOS = () => {
        var ua = window.navigator.userAgent;
        var iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i) || !!ua.match(/iPod/i);
        var webkit = !!ua.match(/WebKit/i);
        var iOSSafari = iOS && webkit && !ua.match(/CriOS/i) && !ua.match(/FxiOS/i);
        var iPad13 = (/iPad|iPhone|iPod/.test(navigator.platform) ||
          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&
          !window.MSStream;
        return iOSSafari || iPad13;
      };

      var GetiOSVersion = () => {
        const ua = navigator.userAgent;
        if (/(iPhone|iPod|iPad)/i.test(ua))
          return ua.match(/OS [\d_]+/i)[0].substr(3).split('_').map(n => parseInt(n));
        // iPad 13
        else if (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && !window.MSStream)
          return ua.match(/Version\/[\d.]+/i)[0].substr(3).split('.').map(n => parseInt(n));
        return [0];
      };

      var UserAgentIsiPhone = () => /iPhone|iPod/.test(navigator.userAgent);

      var IsStandalone = () => (
        (window.matchMedia('(display-mode: standalone)').matches) || 
          (("standalone" in window.navigator) &&
           window.navigator.standalone)
      );

      // https://stackoverflow.com/a/11381730
      var UserAgentIsMobile = () => {
        let check = false;
        (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
        return check;
      };

      var UserAgentIsAndroid = () => /Android/.test(navigator.userAgent);

      ////////////////////////////////
      // Base FS Functions
      ////////////////////////////////

      var GetBasenameFromPath = (path) => path.split('\\').pop().split('/').pop();
      var GetDirnameFromPath = (path) => {
        let arr = path.split('\\').pop().split('/');
        arr.pop();
        return arr.join('/');
      };

      let TypedArrayToBuffer = (array) => array.buffer.slice(array.byteOffset, array.byteLength + array.byteOffset);

      // iOS Safari does not implement Blob.arrayBuffer(), so let's
      // do it ourselves.
      // https://gist.github.com/hanayashiki/8dac237671343e7f0b15de617b0051bd
      function MyArrayBuffer () {
        // this: File or Blob
        return new Promise((resolve) => {
          let fr = new FileReader();
          fr.onload = () => {
            resolve(fr.result);
          };
          fr.readAsArrayBuffer(this);
        })
      }

      var ImplementArrayBuffer = () => {
        if ('File' in self)
          File.prototype.arrayBuffer = File.prototype.arrayBuffer || MyArrayBuffer;
        if ('Blob' in self)
          Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || MyArrayBuffer;
      };

      ImplementArrayBuffer();

      var InitializeFS = () => {
        FS.mkdirTree('/addons');
        FS.symlink('/home/web_user/.srb2', '/addons/.srb2');
        FS.symlink('/home/web_user/.srb2', '/addons/userdata');
        FS.mount(IDBFS, {}, '/home/web_user');
        return (new Promise((resolve, reject) => {
          FS.syncfs(true, (err) => {
            console.log("SyncFS done");
            console.log(err);
            resolve();
          });
        }));
      };

      var WriteFS = (baseDir, path, data) => {
        if (data instanceof ArrayBuffer)
          data = new Uint8Array(data);
        // split path to base dir and filename
        if (path.includes('/') || path.includes('\\'))
          baseDir = `${baseDir}/${GetDirnameFromPath(path)}`;
        fn = GetBasenameFromPath(path);
        // check for symlinks
        let parents = '/';
        baseDir.split('/').forEach((name) => {
          if (name.length) {
            let mode = 0;
            try { mode = FS.lstat(`${parents}${name}`)['mode']; } catch(err) { console.log('WriteFS(): lstat info'); console.log(err); }
            if (FS.isLink(mode))
              parents = `${FS.readlink(`${parents}${name}`)}/`;
            else
              parents += `${name}/`;
          }
        });
        baseDir = parents.substring(0, parents.length-1);
        console.log(`WriteFS(): Writing ${baseDir}/${fn}: ${data.byteLength} bytes`);
        // attempt write
        try { FS.mkdirTree(parents); } catch(err) { console.log('WriteFS(): mkdirTree info'); console.log(err); }
        try { FS.unlink(`${baseDir}/${fn}`); } catch(err) { console.log('WriteFS(): unlink info'); console.log(err); }
        FS.createDataFile(baseDir, fn, data, true, true);
        return Promise.resolve(true);
      };

      var SyncFS = (populate = false) => {
        // commit to persistent storage
        return (new Promise((resolve, reject) => {
          if (typeof FS !== 'undefined')
            FS.syncfs(populate, (err) => {
              console.log('Synced persistent storage');
              console.log(err);
            });
          return resolve();
        }));
      };

      var StartedMainLoop = false;

      var DownloadFS = (downloadPath, manageLoop = true, callback = null) => {
        // Emscripten file store is an IndexedDB, name /home/web_user, object FILE_DATA,
        // version 21.
        // idb-keyval doesn't take in a version parameter (forces 1),
        // so use mazmazz/idb-keyval@idb-version to specify a version.
        // Files are listed as [fullPath]: {timestamp, mode, contents}
        let customStore = new idbKeyval.Store('/home/web_user', 'FILE_DATA', 21);
        if (typeof downloadPath === 'undefined')
          downloadPath = '/home/web_user/.srb2';

        if (manageLoop && StartedMainLoop)
          PauseLoop();

        return SyncFS()
        .then(_ => {
          return idbKeyval.keys(customStore);
        })
        .then(keys => {
          let promises = [];
          let zip = new JSZip();
          keys.forEach(key => {
            if (key.includes(downloadPath))
              promises.push(
                idbKeyval.get(key, customStore)
                .then(val => {
                  // JSZip creates nested folders automatically.
                  // Just iterate over files.
                  if ('contents' in val && val.contents)
                    return zip.file(key.replace('/home/web_user/',''), TypedArrayToBuffer(val.contents), {date: new Date(val.timestamp)});
                })
              );
          });
          return Promise.all(promises)
          .then(_ => zip);
        })
        .then(zip => zip.generateAsync({type:'blob'}))
        .then(blob => Promise.resolve(saveAs(blob, 'srb2-data.zip')))
        .catch(err => console.log(`DownloadFS: ${err}`))
        .finally(_ => {
          if (typeof callback === 'function')
            callback();
          if (manageLoop && StartedMainLoop)
            ResumeLoop();
        });
      };

      var DeleteFS = (deletePath, manageLoop = true, callback = null) => {
        // Emscripten file store is an IndexedDB, name /home/web_user, object FILE_DATA,
        // version 21.
        // idb-keyval doesn't take in a version parameter (forces 1),
        // so use mazmazz/idb-keyval@idb-version to specify a version.
        // Files are listed as [fullPath]: {timestamp, mode, contents}
        if (typeof deletePath === 'undefined')
          throw 'DeleteFS: Must specify a path';

        if (typeof FS !== 'undefined' && FS) {
          try {
            FS.unlink(`${deletePath}`);
          } catch (e) { 
            console.error(`DeleteFS: ${deletePath} - `, e);
          }
          
          return SyncFS().then(_ => {
            if (typeof callback === 'function')
              callback();
            if (manageLoop && StartedMainLoop)
              ResumeLoop();
          });
        }
        
        let customStore = new idbKeyval.Store('/home/web_user', 'FILE_DATA', 21);

        if (manageLoop && StartedMainLoop)
          PauseLoop();

        return SyncFS()
        .then(_ => {
          return idbKeyval.keys(customStore);
        })
        .then(keys => {
          let promises = [];
          keys.forEach(key => {
            if (key.includes(deletePath))
              promises.push(idbKeyval.del(key, customStore));
          });
          return Promise.all(promises)
        })
        .then(_ => SyncFS(true)) // commit changes to the memory FS
        .catch(err => console.log(`DeleteFS: ${err}`))
        .finally(_ => {
          if (typeof callback === 'function')
            callback();
          if (manageLoop && StartedMainLoop)
            ResumeLoop();
        });
      };

      ////////////////////////////////
      // Program Data
      ////////////////////////////////

      // Files to download on first run
      var InstallFiles = [];

      // Files to download on full install (currently unused)
      //var FullInstallFiles = [];

      // Don't delete these files on lump unload
      var PersistentLumpFiles = [];

      // Files to place in FS on game startup
      var StartupFiles = [];

      // Files that must be downloaded before game startup
      var RequiredFiles = [];

      // Store of version bases
      var VersionBases = {};

      var CompositeKey = (fn, version) => `data/${version}/${fn}`;

      var StripLeadingSeparators = (fn) => fn.replace(/^\/*/, '');

      var ResetProgramData = async (manageLoop = true, callback = null) => {
        // Delete specific files in IndexedDB /home/web_user -> FILE_DATA
        // and delete everything in EM_PRELOAD_CACHE -> METADATA, PACKAGES

        let customStore = new idbKeyval.Store('/home/web_user', 'FILE_DATA', 21);
        let customStoreData = new idbKeyval.Store('SRB2_DATA', 'FILES', 1);
        let customStoreEmMetadata = new idbKeyval.Store('EM_PRELOAD_CACHE', 'METADATA', 1);
        let customStoreEmPackages = new idbKeyval.Store('EM_PRELOAD_CACHE', 'PACKAGES', 1);

        if (manageLoop && StartedMainLoop)
          PauseLoop();

        // Let these fail silently in case the keys do not exist.
        var silentCatch = _ => {return;};

        await idbKeyval.clear(customStoreEmMetadata).catch(silentCatch);
        await idbKeyval.clear(customStoreEmPackages).catch(silentCatch);
        // TODO reliable recursive way to clear multiple versions of data?
        // because later versions may use older versions as a BASE
        await idbKeyval.clear(customStoreData).catch(silentCatch);
        // We don't store game assets in the user folder
        await idbKeyval.del('/home/web_user/.srb2/music.dta', customStore).catch(silentCatch);

        if (typeof callback === 'function')
          callback();
        if (manageLoop && StartedMainLoop)
          ResumeLoop();
        
        return Promise.resolve();
      };

      var InstallProgramFileReferences = async (name, version, fullBase) => {
        let customStore = new idbKeyval.Store('SRB2_DATA', 'FILES', 1);
        // Slice all parent bases of the current version, so we don't
        // overwrite parents' files.
        let fullBase2 = fullBase.slice(0, fullBase.indexOf(version));

        return Promise.all(fullBase2.map(async base => {
          if (base && base !== version) {
            let baseFile = await idbKeyval.get(CompositeKey(name, base), customStore);
            if (!(baseFile instanceof Object))
              baseFile = {};
            if (!('contents' in baseFile)) {
              if (!('base' in baseFile && baseFile['base'] != version)) {
                baseFile['base'] = version;
                console.log(`InstallProgramFileReferences: Logging base ${version} for ${name} (${base})`);
                return idbKeyval.set(CompositeKey(name, base), baseFile, customStore);
              } else
                return Promise.resolve(); // nothing to update
            } 
            // IF AN ENTRY EXISTS IN A PARENT BASE: Be wary. Don't log anything,
            // in case the parent file was in error.
            return Promise.reject('While logging parent base references, parent ${base} already has a file.');
          }
        }));
      };

      var InstallProgramFile = async (name, version, md5 = null, fullBase = []) => {
        let customStore = new idbKeyval.Store('SRB2_DATA', 'FILES', 1);

        try {
          let remoteFile = await fetch(`data/${version}/${name}`);

          if (!remoteFile.ok)
            throw remoteFile;
          
          remoteFile = await remoteFile.arrayBuffer();
          remoteFile = new Uint8Array(remoteFile);

          // Log a reference to this version in all the parent bases
          await InstallProgramFileReferences(name, version, fullBase);

          // Log to persistent storage
          let idbFile = await idbKeyval.get(CompositeKey(name, version), customStore);
          if (!idbFile)
            idbFile = {};
          idbFile['contents'] = remoteFile;
          idbFile['md5'] = md5;
          await idbKeyval.set(CompositeKey(name, version), idbFile, customStore);
          console.log(`Downloaded ${name} (${version}) from server.`);
          return Promise.resolve(idbFile);
        } catch (e) {
          // fetch connection error or other throw from above
          throw `CheckInstallProgramFile: data/${version}/${name} - ${e}`;
        }
      };

      var CheckInstallProgramFile = async (name, version, base = [], fullBase = [], checkMd5IfFileExists = false) => {
        // Every data file on the server has a corresponding *.md5 file.
        // Check the server for a file in the given version.
        // If it doesn't exist in the given version, then try the "base" version.

        if (typeof version === 'undefined' || !version) {
          if (base && base.length)
            return CheckInstallProgramFile(name, base.shift(), base, fullBase, checkMd5IfFileExists);
          else
            throw `CheckInstallProgramFile: ${name} - No version to fetch from!`;
        }

        let customStore = new idbKeyval.Store('SRB2_DATA', 'FILES', 1);

        // First, see if we can get a base reference in IDB
        try {
          let localFile = await idbKeyval.get(CompositeKey(name, version), customStore);
          if (localFile && localFile instanceof Object) {
            if ('base' in localFile)
              return await CheckInstallProgramFile(name, localFile['base'], [], fullBase, checkMd5IfFileExists);
            else if (!checkMd5IfFileExists) {
              console.log(`Retrieved ${name} (${version}) from storage.`);
              // Don't log a base reference (InstallProgramFileReferences),
              // because we want to verify with server before doing so.
              return Promise.resolve(localFile);
            }
          }
        } catch (e) { } // fail silently; oh well, we tried.

        try {
          // Check server's MD5 file for the current version.
          let remoteMd5 = await fetch(`data/${version}/${name}.md5`);
          if (!remoteMd5.ok) {
            // Server's MD5 was not found: check the "base" version for the file.
            if (base && base.length && base[0])
              return await CheckInstallProgramFile(name, base.shift(), base, fullBase, checkMd5IfFileExists);
            else if (!RequiredFiles.includes(name))
              return Promise.resolve(); // shrug, we don't need this file.
            else
              throw 'Cannot retrieve MD5';
          } else {
            // Server's MD5 was found: compare it to our local MD5 for the file.
            let idbFile = await idbKeyval.get(CompositeKey(name, version), customStore);
            remoteMd5 = await remoteMd5.text();

            if (idbFile && 'md5' in idbFile
                && remoteMd5 && remoteMd5 == idbFile['md5']) {
              // The MD5's match: we're done, don't download anything.
              // Log a reference to this version in all the parent bases
              await InstallProgramFileReferences(name, version, fullBase);
              console.log(`Retrieved ${name} (${version}) from storage.`);
              return Promise.resolve(idbFile);
            }
            else if (remoteMd5 && remoteMd5.length == 32) { // sanity check
              // The MD5's do not match: store the server's MD5, and download
              // the file for the current version.
              return await InstallProgramFile(name, version, remoteMd5, fullBase);
            } else {
              // Edge case where remote MD5 is not valid: see if there's an older file.
              if (base && base.length && base[0])
                return await CheckInstallProgramFile(name, base.shift(), base, fullBase, checkMd5IfFileExists);
              else if (!RequiredFiles.includes(name))
                return Promise.resolve(); // shrug, we don't need this file.
              else
                throw 'Cannot retrieve remote MD5.';
            }
          }
        } catch (e) {
          // fetch() connection error, or thrown from above code.
          throw `CheckInstallProgramFile: data/${version}/${name}.md5 - ${e}`;
        }
      };

      var CheckInstallFileList = async (fileList, version = '{{{ PACKAGE_VERSION }}}', checkServer = false, progressCallback = null, finishedCallback = null) => {
        let bases = await GetVersionBases(version);
        let files = [...fileList];
        // Using es6-promise-pool to rate-limit file requests.
        // This works like a loop: when the Pool requests a promise,
        // it produces promises based on the count index.
        let count = 0;
        let promiseProducer = () => {
          if (count < files.length) {
            let basesRecursive = [...bases]; // first entry is our own version
            return CheckInstallProgramFile(files[count++], basesRecursive.shift(), basesRecursive, [...bases], checkServer)
            .then(_ => { 
              if (typeof progressCallback === 'function')
                progressCallback(files[count], count, files.length);
            });
          } else
            return null;
        };

        // Prime the progress callback with the first file
        if (typeof progressCallback === 'function')
          progressCallback(files[count], count, files.length);

        let pool = new PromisePool(promiseProducer, 3);

        return pool.start()
        .then(_ => {
          if (typeof finishedCallback === 'function')
            finishedCallback();
        })
        .catch(e => { console.error(`CheckInstallFileList: ${e}`); throw e; });
      };

      var GetVersionFileLists = async (version = '{{{ PACKAGE_VERSION }}}') => {
        let fileLists = {'_INSTALL': InstallFiles,
                         //'_FULLINSTALL': FullInstallFiles,
                         '_PERSISTENT': PersistentLumpFiles,
                         '_STARTUP': StartupFiles,
                         '_REQUIRED': RequiredFiles};
        // Download all file lists
        try {
          await CheckInstallFileList(Object.keys(fileLists), version, true, null, null);
        } catch (e) { console.error('GetVersionFileLists error: ^^^^^'); }

        // Populate local file lists
        // This is inefficent, but pull the files we just downloaded
        // Hopefully we got them all, so we just retrieve them from the IDB.
        await Promise.all(Object.keys(fileLists).map(async (name) => {
          try {
            fileLists[name].length = 0; // clear array, keep reference
            let file = await RetrieveInstalledFile(name, version, false);
            if (file instanceof Object && 'contents' in file && file.contents) {
              // Convert to text file
              let textList = new TextDecoder("utf-8").decode(file.contents);
              textList = textList.replace('\r\n','\n');
              textLines = textList.split('\n');
              // Add entry to file list
              textLines.forEach(line => {
                let lineTrim = line.trim();
                if (lineTrim && !lineTrim.startsWith('//'))
                  fileLists[name].push(lineTrim);
              });
            }
          } catch (e) {
            console.error(`GetVersionFileLists: Could not populate list ${name}`, e);
          }
          return name;
        }));

        // Add PersistentLumpFiles to StartupFiles
        StartupFiles.push(...PersistentLumpFiles);
      };

      var GetVersionBases = async (version = '{{{ PACKAGE_VERSION }}}') => {
        // Build BASE dependency list
        // TODO Do MD5 checks on the remote _BASE files, in the
        // rare event that the base version should change.
        if (VersionBases instanceof Object && version in VersionBases)
          return VersionBases[version];
        let base = [version]; // initialize with our own version, so we can shift() from step 1.
        let baseVer = version;
        try {
          // On a brand-new setup, the store SHOULD be first created here.
          let customStore = new idbKeyval.Store('SRB2_DATA', 'FILES', 1);
          do {
            // Check IDB first
            childBaseVer = await idbKeyval.get(CompositeKey('_BASE', baseVer), customStore);
            if (childBaseVer) {
              if (!base.includes(childBaseVer)) {
                base.push(childBaseVer);
                baseVer = childBaseVer;
              } else
                break; // no circular references, thanks
            } else {
              // If IDB doesn't have the _BASE, then check the server
              childBaseVer = await fetch(`data/${baseVer}/_BASE`);
              if (!childBaseVer.ok)
                // assume no base version, but don't store anything
                // in case this was an error.
                break;
              else {
                childBaseVer = await childBaseVer.text();
                if (childBaseVer) {
                  if (!base.includes(childBaseVer)) {
                    console.log(`GetVersionBases: Logging Base ${childBaseVer} for version ${baseVer}`);
                    await idbKeyval.set(CompositeKey('_BASE', baseVer), childBaseVer, customStore);
                    base.push(childBaseVer);
                    baseVer = childBaseVer;
                  } else {
                    await idbKeyval.set(CompositeKey('_BASE', baseVer), '', customStore);
                    break; // no circular references, thanks
                  }
                } else {
                  await idbKeyval.set(CompositeKey('_BASE', baseVer), '', customStore);
                  break; // no further bases
                }
              }
            }
          } while(baseVer);
        } catch (e) {
          // connection error, don't log anything or continue
          console.error(`GetVersionBases: ${version} (baseVer: ${baseVer}) - ${e}`);
          throw e;
        }
        if (!(VersionBases instanceof Object))
          VersionBases = {};
        VersionBases[version] = [...base];
        return base;
      };

      var InstallProgram = async (full = false, version = '{{{ PACKAGE_VERSION }}}', checkServer = false, progressCallback = null, finishedCallback = null) => {
        let bases = await GetVersionBases(version);
        await GetVersionFileLists(version);
        let files = [...InstallFiles]; // if re-implementing FullInstallFiles, do it here and check for `full`
        return CheckInstallFileList(files, version, checkServer, progressCallback, finishedCallback);
      };

      // UX Function
      var UXInstallProgram = (full, version = '{{{ PACKAGE_VERSION }}}') => {
        HideContent();
        // TODO checkServer -- check for internet connection
        return InstallProgram(full, version, true, (name, curVal, maxVal) => {
          // Progress callback
          let percent = Math.round(curVal/maxVal*100);
          if (typeof name === 'undefined') {
            console.log(`InstallProgram: Finished install (${curVal}/${maxVal}`);
            StatusElement.innerText = `Finishing...`;
          } else {
            console.log(`InstallProgram: Retrieving ${name} (${curVal}/${maxVal})`)
            StatusElement.innerText = `Retrieving ${name.split('/').pop()}...`;
          }
          ProgressElement.value = percent;
        },
        () => {
          // Finished callback
          if (full) {
            alert('Finished install.');
            window.location.reload();
          } else {
            StatusElement.innerText = 'Loading...';
            ProgressElement.value = 0;
          }
        });
      };

      var RetrieveInstalledFile = async (fn, version = '{{{ PACKAGE_VERSION }}}', checkServer = false) => {
        // If IDB file exists, will return the IDB file without checking
        // the web server.
        let bases = await GetVersionBases(version);
        return CheckInstallProgramFile(fn, version, [...bases], [...bases], checkServer);
      };

      var WriteInstalledFileToFS = async (fn, version = '{{{ PACKAGE_VERSION }}}', checkServer = false) => {
        let idbFile = await RetrieveInstalledFile(fn, version, checkServer);
          if (idbFile instanceof Object && 'contents' in idbFile && idbFile['contents'])
            return WriteFS('/', fn, idbFile['contents']);
      };

      var DeleteInstalledFileFromFS = async (fn, persistentFilenames = []) => {
        if (!persistentFilenames.includes(fn))
          return DeleteFS(fn);
      };

      window.addEventListener('load', _=>{
        if (UserAgentIsiOS())
          document.body.classList.add('iOSAgent');
      }, false);
    </script>
    <!-- {{{ SCRIPT }}} -->
  </body>
</html>
